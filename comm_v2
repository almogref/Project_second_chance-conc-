%%%-------------------------------------------------------------------
%%% @author Almog Refaeli
%%% @copyright (C) 2019, <COMPANY>
%%% @doc
%%%
%%% @end
%%% Created : 17. Aug 2019 10:33
%%%-------------------------------------------------------------------
-module(comm_v2).
-author("almog").

-behaviour(gen_server).

-export([start_link/0]).

-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).


%-----------------------------------------------START-LINK--------------------------------------------------------------
% Start link. Register comm_v2 locally and uploading the server.
%-----------------------------------------------------------------------------------------------------------------------

start_link() -> gen_server:start_link({local, comm_v2}, comm_v2, [], []).

%------------------------------------------------INIT-------------------------------------------------------------------
% Initial comm_v2 with default fields.
%-----------------------------------------------------------------------------------------------------------------------

init([]) ->
  {ok, #{numPackets => 0, registers => 0, 1 => {dead,[]}, 2 => {dead,[]}, 3 =>  {dead,[]}, 4 =>  {dead,[]},
  list_mem => [], requester => dead, list_of_deads => [], alives_1 => [4,3,2], alives_4 => [3,2,1], alives_3 => [2,1,4],
  alives_2 => [1,4,3]}}.

%----------------------------------------------TERMINATE----------------------------------------------------------------
% Terminate function for callback functions that fails or returns a bad value.
%-----------------------------------------------------------------------------------------------------------------------

terminate(Reason, _State) ->
  io:format("Callback function fails. Error message:~n~p ",[Reason]).

%----------------------------------------------CHANGE-CODE--------------------------------------------------------------
% Change code function.
%-----------------------------------------------------------------------------------------------------------------------

code_change(_OldVsn, State, _Extra) ->
  {ok, State}.

%------------------------------------------------CLOSE------------------------------------------------------------------
% Sends close messages to all alive nodes
%-----------------------------------------------------------------------------------------------------------------------

close(Members) ->
  lists:foreach(fun({_,Node}) -> gen_server:cast({flock_v4,Node},stop) end ,Members),
  gen_server:stop(comm).

%---------------------------------------------HANDLE-CALL---------------------------------------------------------------
% The only type of call message we support is in the type of registration by the tuple
% {register,Name}. After 4 slaves registrations we initializing and starting the graphic server.
% More specific handle way:
% gets {register,Node} from the client. sends back {ok,id_number}
% saves the new client in the state, ++ {id_number => {ip_node,Table} , ip_node => id_number
% lists of members get upgrade as well, [ {id_number,ip_node} , ... ]
% registers + 1
%-----------------------------------------------------------------------------------------------------------------------
handle_call(Request,_,State = #{registers := OldNum, list_mem := Members}) ->
  case Request of
    {register,Name} ->
                if
                  (OldNum + 1 =:= 4) ->
                          graphic:start_link(comm),
                          erlang:monitor_node(Name,true),
                          gen_server:cast({flock_v4,Name},{connect,OldNum+1}),
                          {noreply,State#{registers := OldNum+1, OldNum+1 := {Name,ets:new(Name,[set])},
                          Name => OldNum+1, list_mem := [{OldNum+1,Name}]++Members}};

                  true ->
                          erlang:monitor_node(Name,true),
                          gen_server:cast({flock_v4,Name},{connect,OldNum+1}),
                          {noreply,State#{registers := OldNum+1, OldNum+1 := {Name,ets:new(Name,[set])},
                          Name => OldNum+1, list_mem := [{OldNum+1,Name}]++Members}}
               end;

    _ElseWhere      ->    {noreply, State}

  end.

%---------------------------------------------HANDLE-CAST---------------------------------------------------------------
% We get the following asynchronous messages:
%
% 1. {package,Data,Id} - incoming list of data that contains new data on the birds from the sender slave,The data can an
%                        empty list so we cover that possibility in the message passing. When we gets a new package
%                        of data, we upgrade the state of the comm_v2 server with it and sending it to graphic that
%                        takes charge from there. Empty packages will be ignored.
%
% 2. state -             ask for that current state of the server. We did it for debugging purposes.
%-----------------------------------------------------------------------------------------------------------------------

handle_cast(_Msg,State = #{numPackets := Num, registers := NumReg}) ->
  case _Msg of
    %----------{package,[],Id}------------%
    {package,[],Id} ->
                {noreply,State};
    %-------- -{package,Package,Id}-------%
    {package,Package,Id} ->
                gen_server:cast(graphic,{data,Package}),
                {Node,Table} = maps:get(Id,State),
                if
                  Num =:= NumReg ->
                    gen_server:cast(graphic,paint),{noreply,State#{numPackets :=0,
                    Id := {Node,ets:insert(Table,{Id,Package})}}};
                  true ->
                    {noreply,State#{numPackets := Num+1, Id := {Node,ets:insert(Table,{Id,Package})}}}
                end;
    %----------------state----------------%
    state ->
                io:format("The state is:~n~p ",[State]),
                {noreply,State};
    %--------------DONT-CARE--------------%
    _ElseWhere ->
                {noreply,State}
  end.

%-----------------------------------------------HANDLE-INFO-------------------------------------------------------------
% We get the following messages:
%
% 1. {go,FirstData} - message that received from the graphic server only when the user request to start and send initial
%                     values(Number of birds to start with). We generate randomly locations and send to each slave the
%                     list of locations in his sector which he needs to manage.
% 2. {update,NumToAdd} - message that received from the graphic server when the user wants to add more birds.
%                        We generate new locations randomly and sends them to the slaves that alive. When there is a
%                        slave which is status is "dead" we send his extra new locations to his neighbour(neighbour
%                        definition is clockwise e.g. node area 1 is the neighbour of node area 2)
% 3. {nodedown,Node} - message the received when a slave is down. If all slaves(we have total of 4) are down, we close
%                      the comm_v2 server and graphic, otherwise we initial the procedure of Handle-Crashes.
%                      Handle-Crashes procedure: We transfer all the last income data from the slave who fall to his
%                      neighbour. We delete from the field "list_mem" the slave who fall and delete his ets table from
%                      in the comm_v2 server. As well, we updating the number of nodes alive in the field registers,
%                      and send cast message to the graphic server with the this number.
%-----------------------------------------------------------------------------------------------------------------------

handle_info(Msg,State = #{registers := Num,list_mem := Members,1 := {N_1,T1},2 := {N_2,T2},3 := {N_3,T3},4 := {N_4,T4},
            alives_1 := NE1, alives_2 := NE2, alives_3 := NE3, alives_4 := NE4, list_of_deads := ListOfDeads}) ->
  case Msg of
    %----------{go,FirstData}------------%
    {go,FirstData} ->
                MapLocations = distribute(gen_locations({1300,700},FirstData),{1300,700},[],[],[],[]),
                send_initial(MapLocations,members_to_list(Members,[]),State,1),
                Requester = spawn(fun() -> requester_loop(Members) end),
                {noreply,State#{requester := Requester}};
    %----------{update,NumToAdd}------------%
    {update,NumToAdd}  ->
                [NL1,NL2,NL3,NL4] = distribute(gen_locations({1300,700},NumToAdd),{1300,700},[],[],[],[]),
                if
                  Num =:= 4 ->
                    send_while(Members,NL1,NL2,NL3,NL4),
                    {noreply,State};
                  true ->
                    re_arange(State,[NL1,NL2,NL3,NL4],ListOfDeads),
                    {noreply,State}
                end;
    %------------{nodedown,Node}------------%
    {nodedown,Node} ->
                if
                  Num =:= 1 ->
                    gen_server:cast(graphic,stop),
                    gen_server:stop(comm);
                  true ->
                    CrashId = maps:get(Node,State),
                    ListOfCrashed = ets:tab2list(element(2,maps:get(CrashId,State))),
                    NewMembers = lists:delete({CrashId,Node},Members),
                    ets:delete_all_objects(element(2,maps:get(CrashId,State))),
                    Neighbour = get_neighbour(CrashId,NE1,NE2,NE3,NE4),
                    [LI1,LI2,LI3,LI4] = clean_sub_lists(CrashId,NE1,NE2,NE3,NE4),
                    [Birds1,Birds2,Birds3,Birds4] = arrange_tables(CrashId,Neighbour,[T1,T2,T3,T4]),
                    gen_server:cast({flock_v4,element(1,maps:get(Neighbour,State))},{flock_down,ListOfCrashed,CrashId}),
                    gen_server:cast(graphic,{down,Num-1}),
                    {noreply,State#{registers := Num-1, CrashId := {dead,[]}, Node := dead, list_mem := NewMembers,
                      list_of_deads := [CrashId] ++ ListOfDeads, alives_1 := LI1, alives_2 := LI2, alives_3 := LI3,
                      alives_4 := LI4, 1 := {N_1,Birds1}, 2 := {N_2,Birds2}, 3 := {N_3,Birds3}, 4 := {N_4,Birds4}}}
                end;
    %----------------stop-----------------%
    stop ->
                  close(Members),
                  {noreply,State};
    %--------------DONT-CARE--------------%
    _ElseWhere ->
                  {noreply,State}
  end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%------------------------------------------- MAINTENANCE-FUNCTIONS -----------------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%----------------------------------------------GEN-LOCATIONS------------------------------------------------------------
% Function that uses gen_location function to generate randomly new locations on the screen.
%-----------------------------------------------------------------------------------------------------------------------

gen_locations(_,0) ->
                [];
gen_locations(Dimensions,N) ->
                [gen_location(Dimensions) | gen_locations(Dimensions,N-1)].

gen_location({Width,Height}) ->
                {rand:uniform(Width),rand:uniform(Height)}.

%-----------------------------------------------DISTRIBUTE--------------------------------------------------------------
% Distribute the locations we generated into the right sectors and arrange it in a list of lists which the first index
% in the output list is the new locations for sector 1, the second index is the new locations for sector 2 and so on.
%-----------------------------------------------------------------------------------------------------------------------

distribute([],_,S1,S2,S3,S4) ->
                [S1,S2,S3,S4];

distribute([Loc|T], Dimensions,S1,S2,S3,S4) ->
                {Width,Height} = Dimensions,
                {X,Y} = Loc,
                Border_W = Width/2,
                Border_H = Height/2,
                if X < Border_W ->
                  if Y < Border_H -> distribute(T,Dimensions,S1, S2 ++ [Loc],S3,S4);
                    true-> distribute(T,Dimensions,S1, S2,S3 ++ [Loc],S4) end;
                  true->
                    if Y < Border_H -> distribute(T,Dimensions,S1 ++ [Loc], S2,S3,S4);
                      true-> distribute(T,Dimensions,S1, S2,S3 ,S4 ++ [Loc])  end
                end.

%----------------------------------------------GET-NEIGHBOUR------------------------------------------------------------
% Gets the right neighbour of the slave by clockwise definition
%-----------------------------------------------------------------------------------------------------------------------

get_neighbour(CrashId,NE1,NE2,NE3,NE4) ->
                case CrashId of
                  1  -> lists:nth(1,NE1);
                  2  -> lists:nth(1,NE2);
                  3  -> lists:nth(1,NE3);
                  4  -> lists:nth(1,NE4)
                end.

%---------------------------------------------CLEAN-SUB-LISTS-----------------------------------------------------------
% Deletes the "dead" slave from all the lists we get. We do it by the id of the "dead" slave.
%-----------------------------------------------------------------------------------------------------------------------

clean_sub_lists(CrashId,NE1,NE2,NE3,NE4) ->
              [lists:delete(CrashId,NE1),lists:delete(CrashId,NE2),lists:delete(CrashId,NE3),lists:delete(CrashId,NE4)].

%----------------------------------------------ARRANGE-TABLES-----------------------------------------------------------
% This function re-arrange the tables of each slave. We gets here when a slave is down and we need to transfer his data.
%-----------------------------------------------------------------------------------------------------------------------

arrange_tables(CrashId,Neighbour,[L1,L2,L3,L4]) ->
              case CrashId of
                1 -> case Neighbour of
                       4 -> [[],L2,L3,L4 ++ L1];
                       3 -> [[],L2,L3 ++ L1,L4];
                       2 -> [[],L2 ++ L1, L3, L4]
                     end;
                2 -> case Neighbour of
                       1 -> [L1 ++ L2,[],L3,L4];
                       3 -> [L1,[],L3 ++ L2, L4];
                       4 -> [L1,[],L3,L1 ++ L4]
                     end;
                3 -> case Neighbour of
                       2 -> [L1,L2 ++ L3, [], L4];
                       1 -> [L1 ++ L3, L2, [], L4];
                       4 -> [L1, L2, [], L4 ++ L3]
                     end;
                4 -> case Neighbour of
                       3 -> [L1, L2, L3 ++ L4,[]];
                       2 -> [L1, L2 ++ L4, L3, []];
                       1 -> [L1 ++ L4, L2, L3, []]
                     end
              end.

%-----------------------------------------REQUESTER-LOOP----------------------------------------------------------------
% Area of code for the Requester. This process handles the request for new data of birds from each slave alive that
% connect to comm_v2 server. He asks for package by sending the message {master_request} to the slave.
% This method happening every 40ms.
%-----------------------------------------------------------------------------------------------------------------------

requester_loop(Members) ->
                loop_by_time(Members),
                timer:sleep(40),
                requester_loop(Members).

loop_by_time([]) ->
                finish_to_send;
loop_by_time([ Node | T ]) ->
                gen_server:cast({flock_v4,element(2,Node)},{master_request}),
                loop_by_time(T).

%------------------------------------------SEND-INITIAL-----------------------------------------------------------------
% Function that sends the first initial data to each slave.
%-----------------------------------------------------------------------------------------------------------------------

send_initial([],_,_,_) ->
                finish_to_send;
send_initial([H|T], Members, State, Offset) ->
                gen_server:cast({flock_v4,element(1,maps:get(Offset,State))},{init,H,Members}),
                send_initial(T, Members,State,Offset+1).

%-------------------------------------------SEND-WHILE------------------------------------------------------------------
% Function that sends new locations to add to each slave who connect to comm_v2 server.
%-----------------------------------------------------------------------------------------------------------------------

send_while([],_,_,_,_) ->
                finish_to_send;
send_while([H|T],L1,L2,L3,L4) ->
                case element(1,H) of
                  1 -> gen_server:cast({flock_v4,element(2,H)},{insert,L1}),send_while(T,L1,L2,L3,L4);
                  2 -> gen_server:cast({flock_v4,element(2,H)},{insert,L2}),send_while(T,L1,L2,L3,L4);
                  3 -> gen_server:cast({flock_v4,element(2,H)},{insert,L3}),send_while(T,L1,L2,L3,L4);
                  4 -> gen_server:cast({flock_v4,element(2,H)},{insert,L4}),send_while(T,L1,L2,L3,L4)
                end.

%------------------------------------------RE-ARANGE--------------------------------------------------------------------
%
% NE(i) is lists of alive neighbours(clockwise) of node i
%-----------------------------------------------------------------------------------------------------------------------

re_arange(State ,_,[]) ->
  State;
re_arange(State = #{alives_1 := NE1, alives_2 := NE2, alives_3 := NE3, alives_4 := NE4}, MapLocations, [H|T]) ->
  IdToSend =                        case H of
                                      % GETS THE BIRDS LIST OF THE NEIGHBOUR
                                      1  -> lists:nth(1,NE1);
                                      2  -> lists:nth(1,NE2);
                                      3  -> lists:nth(1,NE3);
                                      4  -> lists:nth(1,NE4)
                                    end,
  NodeToSend = maps:get(IdToSend,State),
  gen_server:cast({flock_v4,element(1,NodeToSend)},{insert,lists:nth(H,MapLocations)++lists:nth(IdToSend,MapLocations)}),
  re_arange(State,MapLocations,T).

%------------------------------------------MEMBERS-TO-LIST--------------------------------------------------------------
% Function that gets the map list_mem and returns list of the members alive right now.
%-----------------------------------------------------------------------------------------------------------------------

members_to_list([],Acc) ->
                  Acc;
members_to_list([H|T],Acc) ->
                  members_to_list(T, [element(2,H)] ++ Acc).


